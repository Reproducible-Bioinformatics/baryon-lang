package transpiler

import (
	"fmt"
	"strings"

	"github.com/reproducible-bioinformatics/baryon-lang/internal/ast"
)

func init() {
	RegisterTranspiler("bash", &TranspilerDescriptor{
		Extension:   ".sh",
		Display:     "BASH",
		Initializer: func() Transpiler { return NewBashTranspiler() },
	})
}

// BashTranspiler converts Baryon AST to BASH code.
type BashTranspiler struct{ TranspilerBase }

// Transpile implements Transpiler.
func (b *BashTranspiler) Transpile(program *ast.Program) (string, error) {
	b.Buffer.Reset()

	b.writeHeader()

	err := b.writeTypeValidation(program.Parameters)
	if err != nil {
		return "", fmt.Errorf("error writing type validation: %w", err)
	}

	for _, impl := range program.Implementations {
		handler, ok := b.GetImplementationHandlers()[impl.Name]
		if !ok {
			return "", fmt.Errorf("unknown implementation block: %s", impl.Name)
		}
		if err := handler(b, &impl, program); err != nil {
			return "", fmt.Errorf("error processing implementation '%s': %w", impl.Name, err)
		}
	}

	if len(program.Outputs) > 0 {
		b.WriteLine("")
		b.WriteLine("# Outputs")
		for _, output := range program.Outputs {
			b.WriteLine("echo \"Output generated: %s\"", output.Path)
		}
	}

	return b.Buffer.String(), nil
}

func (b *BashTranspiler) writeTypeValidation(params []ast.Parameter) error {
	if len(params) == 0 {
		return nil
	}
	for _, param := range params {
		if param.Default != nil {
			continue
		}
		validator, exists := b.GetTypeValidator()[param.Type]
		if !exists {
			b.WriteLine("# No specific validation for type '%s'", param.Type)
		}
		if err := validator(b, param); err != nil {
			return fmt.Errorf("error validating parameter '%s': %w", param.Name, err)
		}
	}
	return nil
}

func (b *BashTranspiler) GetTypeValidator() map[string]TypeValidator {
	return b.TypeValidators
}

func (b *BashTranspiler) writeHeader() {
	b.WriteLine("#!/bin/bash")
	b.WriteLine("# Generated by Baryon transpiler")
	b.WriteLine("set -euo pipefail")
	b.WriteLine("IFS=$'\\n\\t'")
	b.WriteLine("trap 'echo \"Error on line $LINENO\" >&2' ERR")
	b.WriteLine("")
}

func NewBashTranspiler() *BashTranspiler {
	t := &BashTranspiler{}
	t.Initialize()

	t.RegisterImplementationHandler("run_docker", t.handleDockerImplementation)

	typeValidators := map[string]TypeValidator{
		TypeString:    t.validateStringType,
		TypeNumber:    t.validateNumberType,
		TypeInteger:   t.validateIntegerType,
		TypeBoolean:   t.validateBooleanType,
		TypeEnum:      t.validateEnumType,
		TypeFile:      t.validateFileType,
		TypeDirectory: t.validateDirectoryType,
		TypeCharacter: t.validateCharacterType,
	}

	for name, fn := range typeValidators {
		t.RegisterTypeValidator(name, fn)
	}

	return t
}

// TODO: Implement Docker handling for Bash
func (b *BashTranspiler) handleDockerImplementation(
	base BaseTranspiler,
	impl *ast.ImplementationBlock,
	program *ast.Program,
) error {
	image, ok := impl.Fields["image"].(string)
	if !ok {
		return fmt.Errorf("image field is required and must be a string")
	}

	base.WriteLine("")
	base.WriteLine("# Run Docker container")

	// Build command
	var cmdBuilder strings.Builder
	cmdBuilder.WriteString("docker run --rm")

	// Volumes
	if vols, ok := impl.Fields["volumes"].([]any); ok {
		for _, v := range vols {
			pair, ok := v.([]any)
			if !ok || len(pair) != 2 {
				continue
			}
			hostPath := pair[0].(string)
			containerPath := pair[1].(string)

			if IsParamReference(hostPath, program.Parameters) {
				hostPath = fmt.Sprintf("\"$%s\"", hostPath)
			}

			cmdBuilder.WriteString(fmt.Sprintf(" -v %s:%s", hostPath, containerPath))
		}
	}

	cmdBuilder.WriteString(" " + image)

	// Arguments
	if args, ok := impl.Fields["arguments"].([]any); ok {
		for _, a := range args {
			argStr, ok := a.(string)
			if !ok {
				continue
			}
			if IsParamReference(argStr, program.Parameters) {
				argStr = fmt.Sprintf("\"$%s\"", argStr)
			}
			cmdBuilder.WriteString(" " + argStr)
		}
	}

	base.WriteLine(cmdBuilder.String())
	return nil
}

func (b *BashTranspiler) validateStringType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ -z \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a non-empty string\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateNumberType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid number\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateIntegerType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid integer\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateBooleanType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ \"$" + param.Name + "\" != \"true\" && \"$" + param.Name + "\" != \"false\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be either 'true' or 'false'\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateEnumType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	if len(param.Constraints) == 0 {
		return fmt.Errorf("enum type '%s' must have at least one constraint", param.Name)
	}

	values := make([]string, len(param.Constraints))
	for i, constraint := range param.Constraints {
		values[i] = fmt.Sprintf("%q", constraint)
	}

	base.WriteLine("if [[ ! \"${" + param.Name + "}\" =~ ^(" + strings.Join(values, "|") + ")$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be one of: " + strings.Join(values, ", ") + "\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateFileType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -e \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid file or directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateDirectoryType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -d \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateCharacterType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	return b.validateStringType(base, param)
}
