package transpiler

import (
	"fmt"
	"strings"

	"github.com/reproducible-bioinformatics/baryon-lang/internal/ast"
)

func init() {
	RegisterTranspiler("bash", &TranspilerDescriptor{
		Extension:   ".sh",
		Display:     "BASH",
		Initializer: func() Transpiler { return NewBashTranspiler() },
	})
}

// BashTranspiler converts Baryon AST to BASH code.
type BashTranspiler struct{ TranspilerBase }

// Transpile implements Transpiler.
func (b *BashTranspiler) Transpile(program *ast.Program) (string, error) {
	b.Buffer.Reset()

	b.writeHeader()

	err := b.writeTypeValidation(program.Parameters)
	if err != nil {
		return "", fmt.Errorf("error writing type validation: %w", err)
	}

	return b.Buffer.String(), nil
}

func (b *BashTranspiler) writeTypeValidation(params []ast.Parameter) error {
	if len(params) == 0 {
		return nil
	}
	for _, param := range params {
		if param.Default != nil {
			continue
		}
		validator, exists := b.GetTypeValidator()[param.Type]
		if !exists {
			b.WriteLine("# No specific validation for type '%s'", param.Type)
		}
		if err := validator(b, param); err != nil {
			return fmt.Errorf("error validating parameter '%s': %w", param.Name, err)
		}
	}
	return nil
}

func (b *BashTranspiler) GetTypeValidator() map[string]TypeValidator {
	return b.TypeValidators
}

func (b *BashTranspiler) writeHeader() {
	b.WriteLine("#!/bin/bash")
	b.WriteLine("# Generated by Baryon transpiler")
	b.WriteLine("set -euo pipefail")
	b.WriteLine("IFS=$'\\n\\t'")
	b.WriteLine("trap 'echo \"Error on line $LINENO\" >&2' ERR")
	b.WriteLine("")
}

func NewBashTranspiler() *BashTranspiler {
	t := &BashTranspiler{}
	t.Initialize()

	t.RegisterImplementationHandler("run_docker", t.handleDockerImplementation)

	typeValidators := map[string]TypeValidator{
		TypeString:    t.validateStringType,
		TypeNumber:    t.validateNumberType,
		TypeInteger:   t.validateIntegerType,
		TypeBoolean:   t.validateBooleanType,
		TypeEnum:      t.validateEnumType,
		TypeFile:      t.validateFileType,
		TypeDirectory: t.validateDirectoryType,
		TypeCharacter: t.validateCharacterType,
	}

	for name, fn := range typeValidators {
		t.RegisterTypeValidator(name, fn)
	}

	return t
}

// TODO: Implement Docker handling for Bash
func (b *BashTranspiler) handleDockerImplementation(
	base BaseTranspiler,
	impl *ast.ImplementationBlock,
	program *ast.Program,
) error {
	return nil
}

func (b *BashTranspiler) validateStringType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ -z \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a non-empty string\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateNumberType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid number\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateIntegerType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid integer\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateBooleanType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ \"$" + param.Name + "\" != \"true\" && \"$" + param.Name + "\" != \"false\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be either 'true' or 'false'\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateEnumType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	if len(param.Constraints) == 0 {
		return fmt.Errorf("enum type '%s' must have at least one constraint", param.Name)
	}

	values := make([]string, len(param.Constraints))
	for i, constraint := range param.Constraints {
		values[i] = fmt.Sprintf("%q", constraint)
	}

	base.WriteLine("if [[ ! \"${" + param.Name + "}\" =~ ^(" + strings.Join(values, "|") + ")$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be one of: " + strings.Join(values, ", ") + "\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateFileType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -e \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid file or directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateDirectoryType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -d \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateCharacterType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	return b.validateStringType(base, param)
}
