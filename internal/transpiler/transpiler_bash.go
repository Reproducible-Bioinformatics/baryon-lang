package transpiler

import (
	"fmt"
	"strings"

	"github.com/reproducible-bioinformatics/baryon-lang/internal/ast"
)

func init() {
	RegisterTranspiler("bash", &TranspilerDescriptor{
		Extension:   ".sh",
		Display:     "BASH",
		Initializer: func() Transpiler { return NewBashTranspiler() },
	})
}

// BashTranspiler converts Baryon AST to BASH code.
type BashTranspiler struct{ TranspilerBase }

// Transpile implements Transpiler.
func (b *BashTranspiler) Transpile(program *ast.Program) (string, error) {
	b.Buffer.Reset()

	b.writeHeader()
	b.writeUtilityFunctions()
	b.writeArgumentParsing(program.Parameters)

	err := b.writeTypeValidation(program.Parameters)
	if err != nil {
		return "", fmt.Errorf("error writing type validation: %w", err)
	}

	for _, impl := range program.Implementations {
		handler, ok := b.GetImplementationHandlers()[impl.Name]
		if !ok {
			return "", fmt.Errorf("unknown implementation block: %s", impl.Name)
		}
		if err := handler(b, &impl, program); err != nil {
			return "", fmt.Errorf("error processing implementation '%s': %w", impl.Name, err)
		}
	}

	if len(program.Outputs) > 0 {
		b.WriteLine("")
		b.WriteLine("# Outputs")
		for _, output := range program.Outputs {
			b.WriteLine("echo \"Output generated: %s\"", output.Path)
		}
	}

	return b.Buffer.String(), nil
}

func (b *BashTranspiler) writeUtilityFunctions() {
	b.WriteLine("# Utility functions")
	b.WriteLine("log_info() { echo \"[INFO] $*\" >&2; }")
	b.WriteLine("log_error() { echo \"[ERROR] $*\" >&2; }")
	b.WriteLine("")
	b.WriteLine("check_docker() {")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("if ! command -v docker &> /dev/null; then")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("log_error \"Docker is not installed or not in PATH.\"")
	b.WriteLine("exit 1")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("fi")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("}")
	b.WriteLine("")
	b.WriteLine("run_docker() {")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("local image=\"$1\"; shift")
	b.WriteLine("local opts=()")
	b.WriteLine("while [[ $# -gt 0 && \"$1\" != \"--\" ]]; do")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("opts+=(\"$1\"); shift")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("done")
	b.WriteLine("[[ \"$1\" == \"--\" ]] && shift")
	b.WriteLine("log_info \"Running Docker image: $image\"")
	b.WriteLine("docker run --rm \"${opts[@]}\" \"$image\" \"$@\"")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("}")
	b.WriteLine("")
}

func (b *BashTranspiler) writeArgumentParsing(params []ast.Parameter) {
	b.WriteLine("# Argument parsing")
	b.WriteLine("usage() {")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("echo \"Usage: $0 [options]\"")
	for _, param := range params {
		b.WriteLine("echo \"  --%s <value>\"", param.Name)
	}
	b.WriteLine("exit 1")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("}")
	b.WriteLine("")

	b.WriteLine("# Initialize variables")
	for _, param := range params {
		if param.Default != nil {
			b.WriteLine("%s=\"%v\"", param.Name, param.Default)
		} else {
			b.WriteLine("%s=\"\"", param.Name)
		}
	}
	b.WriteLine("")

	b.WriteLine("while [[ $# -gt 0 ]]; do")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("key=\"$1\"")
	b.WriteLine("case $key in")
	b.SetIndentLevel(b.GetIndentLevel() + 1)

	for _, param := range params {
		b.WriteLine("--%s)", param.Name)
		b.SetIndentLevel(b.GetIndentLevel() + 1)
		if param.Type == "boolean" {
			b.WriteLine("%s=\"true\"", param.Name)
			b.WriteLine("shift")
		} else {
			b.WriteLine("%s=\"$2\"", param.Name)
			b.WriteLine("shift")
			b.WriteLine("shift")
		}
		b.SetIndentLevel(b.GetIndentLevel() - 1)
		b.WriteLine(";;")
	}

	b.WriteLine("-h|--help)")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("usage")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine(";;")
	b.WriteLine("*)")
	b.SetIndentLevel(b.GetIndentLevel() + 1)
	b.WriteLine("log_error \"Unknown option: $1\"")
	b.WriteLine("usage")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine(";;")

	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("esac")
	b.SetIndentLevel(b.GetIndentLevel() - 1)
	b.WriteLine("done")
	b.WriteLine("")
}

func (b *BashTranspiler) writeTypeValidation(params []ast.Parameter) error {
	if len(params) == 0 {
		return nil
	}
	for _, param := range params {
		if param.Default != nil {
			continue
		}
		validator, exists := b.GetTypeValidator()[param.Type]
		if !exists {
			b.WriteLine("# No specific validation for type '%s'", param.Type)
		}
		if err := validator(b, param); err != nil {
			return fmt.Errorf("error validating parameter '%s': %w", param.Name, err)
		}
	}
	return nil
}

func (b *BashTranspiler) GetTypeValidator() map[string]TypeValidator {
	return b.TypeValidators
}

func (b *BashTranspiler) writeHeader() {
	b.WriteLine("#!/bin/bash")
	b.WriteLine("# Generated by Baryon transpiler")
	b.WriteLine("set -euo pipefail")
	b.WriteLine("IFS=$'\\n\\t'")
	b.WriteLine("trap 'echo \"Error on line $LINENO\" >&2' ERR")
	b.WriteLine("")
}

func NewBashTranspiler() *BashTranspiler {
	t := &BashTranspiler{}
	t.Initialize()

	t.RegisterImplementationHandler("run_docker", t.handleDockerImplementation)

	typeValidators := map[string]TypeValidator{
		TypeString:    t.validateStringType,
		TypeNumber:    t.validateNumberType,
		TypeInteger:   t.validateIntegerType,
		TypeBoolean:   t.validateBooleanType,
		TypeEnum:      t.validateEnumType,
		TypeFile:      t.validateFileType,
		TypeDirectory: t.validateDirectoryType,
		TypeCharacter: t.validateCharacterType,
	}

	for name, fn := range typeValidators {
		t.RegisterTypeValidator(name, fn)
	}

	return t
}

// TODO: Implement Docker handling for Bash
func (b *BashTranspiler) handleDockerImplementation(
	base BaseTranspiler,
	impl *ast.ImplementationBlock,
	program *ast.Program,
) error {
	image, ok := impl.Fields["image"].(string)
	if !ok {
		return fmt.Errorf("image field is required and must be a string")
	}

	base.WriteLine("")
	base.WriteLine("# Process file paths for Docker")
	fileParams := IdentifyFileParameters(program.Parameters)
	for _, param := range fileParams {
		base.WriteLine("%s_abspath=$(cd \"$(dirname \"$%s\")\" && pwd)/$(basename \"$%s\")", param, param, param)
		base.WriteLine("%s_dir=$(dirname \"$%s_abspath\")", param, param)
		base.WriteLine("%s_filename=$(basename \"$%s_abspath\")", param, param)
	}

	base.WriteLine("")
	base.WriteLine("check_docker")
	base.WriteLine("")
		base.WriteLine("# Run Docker container")
		
		base.WriteLine("docker_opts=()")
		// Environment variables
		if envs, ok := impl.Fields["env"].([]any); ok {
			for _, e := range envs {
				pair, ok := e.([]any)
				if !ok || len(pair) != 2 {
					continue
				}
				key := pair[0].(string)
				val := pair[1].(string)
				if IsParamReference(val, program.Parameters) {
					base.WriteLine("docker_opts+=(-e \"%s=$%s\")", key, val)
				} else {
					base.WriteLine("docker_opts+=(-e \"%s=%s\")", key, val)
				}
			}
		}
	
		// Volumes
		if vols, ok := impl.Fields["volumes"].([]any); ok && len(vols) > 0 {
			for _, v := range vols {
				pair, ok := v.([]any)
				if !ok || len(pair) != 2 {
					continue
				}
				hostPath := pair[0].(string)
				containerPath := pair[1].(string)
	
				if IsParamReference(hostPath, program.Parameters) {
					// Use the _dir variable for file parameters to mount the directory
					if Contains(fileParams, hostPath) {
						base.WriteLine("docker_opts+=(-v \"$%s_dir:%s\")", hostPath, containerPath)
					} else {
						base.WriteLine("docker_opts+=(-v \"$%s:%s\")", hostPath, containerPath)
					}
				} else if hostPath == "parent-folder" || hostPath == "parent_folder" {
					base.WriteLine("docker_opts+=(-v \"$(pwd):%s\")", containerPath)
				} else {
					base.WriteLine("docker_opts+=(-v \"%s:%s\")", hostPath, containerPath)
				}
			}
		} else {
			if len(fileParams) > 0 {
				base.WriteLine("docker_opts+=(-v \"$%s_dir:/data\")", fileParams[0])
			} else {
				base.WriteLine("docker_opts+=(-v \"$(pwd):/data\")")
			}
		}
	
		base.WriteLine("container_args=()")
		if args, ok := impl.Fields["arguments"].([]any); ok {
			for _, a := range args {
				argStr, ok := a.(string)
				if !ok {
					continue
				}
				if IsParamReference(argStr, program.Parameters) {
					if Contains(fileParams, argStr) {
						base.WriteLine("container_args+=(\"$%s_filename\")", argStr)
					} else {
						base.WriteLine("container_args+=(\"$%s\")", argStr)
					}
				} else {
					base.WriteLine("container_args+=(\"%s\")", argStr)
				}
			}
		}
	
		base.WriteLine("run_docker \"%s\" \"${docker_opts[@]}\" -- \"${container_args[@]}\"", image)
		return nil
	}
	func (b *BashTranspiler) validateStringType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ -z \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a non-empty string\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateNumberType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid number\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateIntegerType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if ! [[ \"$" + param.Name + "\" =~ ^-?[0-9]+$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid integer\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateBooleanType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ \"$" + param.Name + "\" != \"true\" && \"$" + param.Name + "\" != \"false\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be either 'true' or 'false'\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateEnumType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	if len(param.Constraints) == 0 {
		return fmt.Errorf("enum type '%s' must have at least one constraint", param.Name)
	}

	values := make([]string, len(param.Constraints))
	for i, constraint := range param.Constraints {
		values[i] = fmt.Sprintf("%q", constraint)
	}

	base.WriteLine("if [[ ! \"${" + param.Name + "}\" =~ ^(" + strings.Join(values, "|") + ")$ ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be one of: " + strings.Join(values, ", ") + "\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateFileType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -e \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid file or directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateDirectoryType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	base.WriteLine("if [[ ! -d \"$" + param.Name + "\" ]]; then")
	base.SetIndentLevel(base.GetIndentLevel() + 1)
	base.WriteLine("echo \"Error: " + param.Name + " must be a valid directory\" >&2")
	base.WriteLine("exit 1")
	base.SetIndentLevel(base.GetIndentLevel() - 1)
	base.WriteLine("fi")
	return nil
}

func (b *BashTranspiler) validateCharacterType(
	base BaseTranspiler,
	param ast.Parameter,
) error {
	return b.validateStringType(base, param)
}
